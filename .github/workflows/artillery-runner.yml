name: "Artillery Load Test (Multi-Runner)"

# Dynamic run-name shown in GitHub Actions UI
# Uses user-provided run_id if available, otherwise generates formatted descriptive name
run-name: >
  Artillery Workflow: ${{ github.event.inputs.test_name }}
                
on:
  workflow_dispatch:
    inputs:
      test_type:
        description: "Choose test type (e.g., load/cleanup)"
        required: true
        type: choice
        options:
          - load
          - cleanup
      runners_to_use:
        description: "Number of parallel runners to use (1â€“4)"
        required: true
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
      scenario_file:
        description: "YAML file for Artillery test (e.g., cloudrun-loadtest.yml)"
        required: true
        default: "weighted_scenario.yml,cloudrun-loadtest.yml"
      test_name:
        description: "Optional test name; if blank, YYYYMMDD will be used"
        required: false
        default: ""
      cleanup_days:
        description: "Delete reports older than X days (cleanup mode)"
        required: false
        default: "7"
      print_machine_info:
        description: "Set true to print machine details"
        required: false
        type: choice
        options:
          - "true"
          - "false"

env:
  ARTILLERY_VERSION: "2.0.26"
  SCRIPTS_DIR: "./scripts"
  DATA_DIR: "./data"
  REPORT_DIR: "./artillery-results"

jobs:
  # =========================================================
  # ðŸ§¹ Cleanup Job (runs ONLY when test_type == cleanup)
  # =========================================================
  cleanup:
    if: ${{ github.event.inputs.test_type == 'cleanup' }}
    name: Cleanup Old Reports
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # List artifacts and clean up based on retention
      - name: Delete old artifacts via REST API
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          DAYS: ${{ github.event.inputs.cleanup_days }}
        run: |
          echo "ðŸ” Checking for artifacts older than $DAYS days to delete..."
          cutoff_date=$(date -d "$DAYS days ago" --utc +%s)
          gh api -H "Accept: application/vnd.github+json" /repos/$REPO/actions/artifacts --paginate \
            | jq -r '.artifacts[] | [.name, .id, .created_at] | @tsv' \
            | while IFS=$'\t' read -r name id created_at; do
                created_epoch=$(date -d "$created_at" --utc +%s)
                if [ "$created_epoch" -lt "$cutoff_date" ]; then
                  echo "ðŸ—‘ï¸ Deleting artifact: $name (ID: $id)"
                  gh api --method DELETE /repos/$REPO/actions/artifacts/$id || true
                fi
              done
          echo "âœ… Cleanup complete for artifacts older than $DAYS days."

  # =========================================================
  # ðŸ§ª Run Artillery on multiple runners (skipped if cleanup)
  # =========================================================
  run-artillery:
    if: ${{ github.event.inputs.test_type != 'cleanup' }}
    name: Run Artillery - Runner ${{ matrix.runner_index }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        runner_index: [1, 2, 3, 4]

    steps:
      # Step 0: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step 0.1: Optional machine info
      - name: Print machine details
        if: ${{ github.event.inputs.print_machine_info == 'true' }}
        shell: bash
        run: |
          echo "===== Machine Info ====="
          echo "CPU cores: $(nproc)"
          echo "Memory:"
          free -h
          echo "Public IP: $(curl -s ifconfig.me)"
          echo "Location info:"
          curl -s https://ipapi.co/json/ || echo "Location lookup failed"
          echo "========================"

      # Step 1: Skip unused runners gracefully
      - name: Skip unused runner jobs
        if: ${{ matrix.runner_index > fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          echo "Skipping runner ${{ matrix.runner_index }} (not selected)"
          exit 0

      # Step 2: Setup Python before running tests
      - name: Setup Python
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # Step 3: Install Python dependencies
      - name: Install Python Dependencies
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          python -m pip install --upgrade pip
          pip install pandas plotly numpy pyyaml

      # Step 4: Check scenario YAML exists
      - name: Check scenario YAML exists
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        shell: bash
        run: |
          if [ ! -f "${{ env.SCRIPTS_DIR }}/${{ github.event.inputs.scenario_file }}" ]; then
            echo "Scenario file not found!"
            exit 1
          else
            echo "Found scenario file: ${{ env.SCRIPTS_DIR }}/${{ github.event.inputs.scenario_file }}"
          fi

      # Step 5: Setup Node.js for Artillery
      - name: Setup Node.js
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      # Step 6: Install Artillery and plugin
      - name: Install Artillery + Plugin
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          npm install -g artillery@${{ env.ARTILLERY_VERSION }}
          npm install --save-dev artillery-plugin-metrics-by-endpoint
          artillery --version

      # Step 7: Run Artillery test and generate JSON + HTML
      - name: Run Artillery Test
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        id: run_test
        shell: bash
        run: |
          mkdir -p "${{ env.REPORT_DIR }}"
          TIMESTAMP=$(date +%Y%m%d)
          RANDOM_SUFFIX=$(head /dev/urandom | tr -dc a-z0-9 | head -c 6)
          if [ -z "${{ github.event.inputs.test_name }}" ]; then
            TEST_NAME="test-$TIMESTAMP"
          else
            TEST_NAME="${{ github.event.inputs.test_name }}"
          fi
          RESULT_JSON="${TEST_NAME}-runner-${{ matrix.runner_index }}-${RANDOM_SUFFIX}.json"
          RESULT_HTML="${TEST_NAME}-runner-${{ matrix.runner_index }}-${RANDOM_SUFFIX}-full.html"
          echo "Running Artillery test, output JSON: $RESULT_JSON"
          ARTILLERY_TARGET="${{ vars.BASE_URL }}" \
          API_KEY="${{ secrets.API_KEY }}" \
          AUTH_HEADER="${{ secrets.AUTH_HEADER }}" \
          npx artillery run "${{ env.SCRIPTS_DIR }}/${{ github.event.inputs.scenario_file }}" \
          --output "${{ env.REPORT_DIR }}/$RESULT_JSON" --quiet
          npx artillery report "${{ env.REPORT_DIR }}/$RESULT_JSON" --output "${{ env.REPORT_DIR }}/$RESULT_HTML"
          echo "result_json=$RESULT_JSON" >> $GITHUB_OUTPUT
          echo "result_html=$RESULT_HTML" >> $GITHUB_OUTPUT

      # Step 8: Generate runner-specific Python dashboard
      - name: Generate Python dashboard for this runner
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        shell: bash
        run: |
          RUNNER_HTML="${{ env.REPORT_DIR }}/runner-${{ matrix.runner_index }}-dashboard.html"
          python "${GITHUB_WORKSPACE}/generate_artillery_dashboard.py" \
            --json "${{ env.REPORT_DIR }}/${{ steps.run_test.outputs.result_json }}" \
            --yaml "${{ env.SCRIPTS_DIR }}/${{ github.event.inputs.scenario_file }}" \
            --output "$RUNNER_HTML"
          echo "Generated Python dashboard for runner ${{ matrix.runner_index }}: $RUNNER_HTML"

      # Step 9: Package results into ZIP
      - name: Package Artillery results into ZIP
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        shell: bash
        run: |
          ZIP_NAME="runner-${{ matrix.runner_index }}-results.zip"
          mkdir -p upload
          zip -r "upload/$ZIP_NAME" "${{ env.REPORT_DIR }}/$RESULT_JSON" \
                                  "${{ env.REPORT_DIR }}/logs" \
                                  "${{ env.REPORT_DIR }}/runner-${{ matrix.runner_index }}-dashboard.html"
          echo "Packaged runner ZIP: upload/$ZIP_NAME"

      # Step 10: Upload runner ZIP artifact
      - name: Upload runner artifact
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        uses: actions/upload-artifact@v4
        with:
          name: artillery-results-runner-${{ matrix.runner_index }}
          path: upload/*.zip
        continue-on-error: true

# =========================================================
# ðŸ“Š Aggregate reports (only if NOT cleanup)
# =========================================================
  aggregate-reports:
    if: ${{ github.event.inputs.test_type != 'cleanup' }}
    needs: run-artillery
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all runner artifacts
        uses: actions/download-artifact@v4
        with:
          path: artillery-results

      - name: Extract all runner ZIPs
        shell: bash
        run: |
          mkdir -p combined-results
          for zipfile in artillery-results/**/*.zip; do
            [ -f "$zipfile" ] || continue
            foldername=$(basename "$zipfile" .zip)
            mkdir -p combined-results/"$foldername"
            unzip -o "$zipfile" -d combined-results/"$foldername"
          done

      - name: Determine test name for consolidated files
        id: test_name
        shell: bash
        run: |
          if [ -z "${{ github.event.inputs.test_name }}" ]; then
            CONSOLIDATED_NAME="test-$(date +%Y%m%d)"
          else
            CONSOLIDATED_NAME="${{ github.event.inputs.test_name }}"
          fi
          echo "consolidated_test_name=$CONSOLIDATED_NAME" >> $GITHUB_OUTPUT

      - name: Collect all JSON filenames
        id: collect_jsons
        shell: bash
        run: |
          JSON_FILES=$(find combined-results -name '*.json' -type f | paste -sd "," -)
          if [ -z "$JSON_FILES" ]; then
            echo "No JSON files found. Skipping final dashboard generation."
            echo "json_files=" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "json_files=$JSON_FILES" >> $GITHUB_OUTPUT

      - name: Setup Python
        if: ${{ steps.collect_jsons.outputs.json_files != '' }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python Dependencies
        if: ${{ steps.collect_jsons.outputs.json_files != '' }}
        run: |
          python -m pip install --upgrade pip
          pip install pandas pyyaml plotly numpy

      - name: Generate consolidated Python dashboard
        if: ${{ steps.collect_jsons.outputs.json_files != '' }}
        shell: bash
        run: |
          FINAL_HTML="${{ steps.test_name.outputs.consolidated_test_name }}-consolidated-dashboard.html"
          python "${GITHUB_WORKSPACE}/generate_artillery_dashboard.py" \
            --json "${{ steps.collect_jsons.outputs.json_files }}" \
            --yaml "${{ env.SCRIPTS_DIR }}/${{ github.event.inputs.scenario_file }}" \
            --output "$FINAL_HTML"

      - name: Package consolidated artifacts
        if: ${{ steps.collect_jsons.outputs.json_files != '' }}
        shell: bash
        run: |
          mkdir -p final-upload
          cp artillery-results/**/*.zip final-upload/
          cp "${{ steps.test_name.outputs.consolidated_test_name }}-consolidated-dashboard.html" final-upload/
          zip -r "${{ steps.test_name.outputs.consolidated_test_name }}-consolidated-results.zip" final-upload/

      - name: Upload consolidated artifacts
        if: ${{ steps.collect_jsons.outputs.json_files != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: consolidated-artillery-results
          path: "${{ steps.test_name.outputs.consolidated_test_name }}-consolidated-results.zip"
